/*
 * CryptoWeather
 * The CryptoWeather API allows for access to all of the cryptocurrency data and market forecast services provided. There are two primary categories of routes, `public` and `private`, where `public` routes are accessible to the general public and do not require API authentication, and `private` routes, which require API authentication.  ## General Overview  1. All API methods adhere to RESTful best practices as closely as possible. As such, all API calls will be made via the standard HTTP protocol using the GET/POST/PUT/DELETE request types.  2. Every request returns the status as a JSON response with the following:     - success, true if it was successful     - code, the http status code (also in the response header)         - 200 if response is successful         - 400 if bad request         - 401 if authorization JWT is wrong or limit exceeded         - 404 wrong route         - 500 for any internal errors     - status, the status of the request, default **success**     - errors, an array of any relevant error details  3. For any requests that are not successful an error message is specified and returned as an array for the **errors** key in the JSON response.  4. All authentication uses JSON Web Tokens (JWT), which is set as the **Authorization** entry in the header, see the following for more details.     - http://jwt.io     - https://scotch.io/tutorials/the-anatomy-of-a-json-web-token  ## Code Example  The following is a code example in Python, which demonstrates using the [Python Requests library](https://requests.readthedocs.io/en/master/) for both the `public` and `private` API routes.  ``` import requests  HOST = \"https://api.cryptoweather.ai/v1\"  # Your API key (JWT) API_KEY = \"<YOUR API KEY>\"  # Example public request, no API key required. requests.get(\"{}/public/symbols\".format(HOST)).json()  # Get the current btc price using the public route requests.get(\"{}/public/price-current/{}\".format(HOST, \"btc\")).json()   # Example private request, API key required. Get the btc hourly forecasts headers = {\"Authorization\": \"Bearer {}\".format(API_KEY)} requests.get(\"{}/private/forecast/{}/{}\".format(HOST, \"btc\", \"1h\"),              headers=headers).json() ```
 *
 * OpenAPI spec version: 
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.swagger.client.api;

import io.swagger.client.ApiCallback;
import io.swagger.client.ApiClient;
import io.swagger.client.ApiException;
import io.swagger.client.ApiResponse;
import io.swagger.client.Configuration;
import io.swagger.client.Pair;
import io.swagger.client.ProgressRequestBody;
import io.swagger.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import io.swagger.client.model.DefaultResponse;
import io.swagger.client.model.PrivateAccuracyResponse;
import io.swagger.client.model.PrivateForecastAccuracyResponse;
import io.swagger.client.model.PrivateForecastResponse;
import io.swagger.client.model.PrivateForecastTimeResponse;
import io.swagger.client.model.PrivateTrendTabularResponse;
import io.swagger.client.model.PublicTrendResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class PrivateApi {
    private ApiClient apiClient;

    public PrivateApi() {
        this(Configuration.getDefaultApiClient());
    }

    public PrivateApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for v1PrivateAccuracySymbolIntervalPeriodGet
     * @param symbol The cryptocurrency symbol. (required)
     * @param interval The forecast interval, 1h or 1d. (required)
     * @param period The period for computing the accuracy, such as the past 7 days. (required)
     * @param cookie e.g. csrf&#x3D;b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param xCsrf e.g. b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call v1PrivateAccuracySymbolIntervalPeriodGetCall(String symbol, String interval, String period, String cookie, String xCsrf, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/private/accuracy/{symbol}/{interval}/{period}"
            .replaceAll("\\{" + "symbol" + "\\}", apiClient.escapeString(symbol.toString()))
            .replaceAll("\\{" + "interval" + "\\}", apiClient.escapeString(interval.toString()))
            .replaceAll("\\{" + "period" + "\\}", apiClient.escapeString(period.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (cookie != null)
        localVarHeaderParams.put("Cookie", apiClient.parameterToString(cookie));
        if (xCsrf != null)
        localVarHeaderParams.put("X-csrf", apiClient.parameterToString(xCsrf));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call v1PrivateAccuracySymbolIntervalPeriodGetValidateBeforeCall(String symbol, String interval, String period, String cookie, String xCsrf, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'symbol' is set
        if (symbol == null) {
            throw new ApiException("Missing the required parameter 'symbol' when calling v1PrivateAccuracySymbolIntervalPeriodGet(Async)");
        }
        
        // verify the required parameter 'interval' is set
        if (interval == null) {
            throw new ApiException("Missing the required parameter 'interval' when calling v1PrivateAccuracySymbolIntervalPeriodGet(Async)");
        }
        
        // verify the required parameter 'period' is set
        if (period == null) {
            throw new ApiException("Missing the required parameter 'period' when calling v1PrivateAccuracySymbolIntervalPeriodGet(Async)");
        }
        

        com.squareup.okhttp.Call call = v1PrivateAccuracySymbolIntervalPeriodGetCall(symbol, interval, period, cookie, xCsrf, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Accuracy
     * The accuracy response contains the following attributes.  + &#x60;rmse&#x60; Root Mean Square Error  + &#x60;mae&#x60; Mean Absolute error  + &#x60;r2&#x60; R Squared  + &#x60;ci&#x60; Confidence Interval lower and upper error bounds
     * @param symbol The cryptocurrency symbol. (required)
     * @param interval The forecast interval, 1h or 1d. (required)
     * @param period The period for computing the accuracy, such as the past 7 days. (required)
     * @param cookie e.g. csrf&#x3D;b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param xCsrf e.g. b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @return PrivateAccuracyResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public PrivateAccuracyResponse v1PrivateAccuracySymbolIntervalPeriodGet(String symbol, String interval, String period, String cookie, String xCsrf) throws ApiException {
        ApiResponse<PrivateAccuracyResponse> resp = v1PrivateAccuracySymbolIntervalPeriodGetWithHttpInfo(symbol, interval, period, cookie, xCsrf);
        return resp.getData();
    }

    /**
     * Accuracy
     * The accuracy response contains the following attributes.  + &#x60;rmse&#x60; Root Mean Square Error  + &#x60;mae&#x60; Mean Absolute error  + &#x60;r2&#x60; R Squared  + &#x60;ci&#x60; Confidence Interval lower and upper error bounds
     * @param symbol The cryptocurrency symbol. (required)
     * @param interval The forecast interval, 1h or 1d. (required)
     * @param period The period for computing the accuracy, such as the past 7 days. (required)
     * @param cookie e.g. csrf&#x3D;b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param xCsrf e.g. b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @return ApiResponse&lt;PrivateAccuracyResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<PrivateAccuracyResponse> v1PrivateAccuracySymbolIntervalPeriodGetWithHttpInfo(String symbol, String interval, String period, String cookie, String xCsrf) throws ApiException {
        com.squareup.okhttp.Call call = v1PrivateAccuracySymbolIntervalPeriodGetValidateBeforeCall(symbol, interval, period, cookie, xCsrf, null, null);
        Type localVarReturnType = new TypeToken<PrivateAccuracyResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Accuracy (asynchronously)
     * The accuracy response contains the following attributes.  + &#x60;rmse&#x60; Root Mean Square Error  + &#x60;mae&#x60; Mean Absolute error  + &#x60;r2&#x60; R Squared  + &#x60;ci&#x60; Confidence Interval lower and upper error bounds
     * @param symbol The cryptocurrency symbol. (required)
     * @param interval The forecast interval, 1h or 1d. (required)
     * @param period The period for computing the accuracy, such as the past 7 days. (required)
     * @param cookie e.g. csrf&#x3D;b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param xCsrf e.g. b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call v1PrivateAccuracySymbolIntervalPeriodGetAsync(String symbol, String interval, String period, String cookie, String xCsrf, final ApiCallback<PrivateAccuracyResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = v1PrivateAccuracySymbolIntervalPeriodGetValidateBeforeCall(symbol, interval, period, cookie, xCsrf, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<PrivateAccuracyResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for v1PrivateForecastAccuracySymbolIntervalPeriodGet
     * @param symbol The cryptocurrency symbol. (required)
     * @param interval The forecast interval, 1h or 1d. (required)
     * @param period The period for computing the error bounds, typically 7d or 30d. (required)
     * @param cookie e.g. csrf&#x3D;b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param xCsrf e.g. b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call v1PrivateForecastAccuracySymbolIntervalPeriodGetCall(String symbol, String interval, String period, String cookie, String xCsrf, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/private/forecast-accuracy/{symbol}/{interval}/{period}"
            .replaceAll("\\{" + "symbol" + "\\}", apiClient.escapeString(symbol.toString()))
            .replaceAll("\\{" + "interval" + "\\}", apiClient.escapeString(interval.toString()))
            .replaceAll("\\{" + "period" + "\\}", apiClient.escapeString(period.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (cookie != null)
        localVarHeaderParams.put("Cookie", apiClient.parameterToString(cookie));
        if (xCsrf != null)
        localVarHeaderParams.put("X-csrf", apiClient.parameterToString(xCsrf));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call v1PrivateForecastAccuracySymbolIntervalPeriodGetValidateBeforeCall(String symbol, String interval, String period, String cookie, String xCsrf, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'symbol' is set
        if (symbol == null) {
            throw new ApiException("Missing the required parameter 'symbol' when calling v1PrivateForecastAccuracySymbolIntervalPeriodGet(Async)");
        }
        
        // verify the required parameter 'interval' is set
        if (interval == null) {
            throw new ApiException("Missing the required parameter 'interval' when calling v1PrivateForecastAccuracySymbolIntervalPeriodGet(Async)");
        }
        
        // verify the required parameter 'period' is set
        if (period == null) {
            throw new ApiException("Missing the required parameter 'period' when calling v1PrivateForecastAccuracySymbolIntervalPeriodGet(Async)");
        }
        

        com.squareup.okhttp.Call call = v1PrivateForecastAccuracySymbolIntervalPeriodGetCall(symbol, interval, period, cookie, xCsrf, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Forecast Accuracy
     * 
     * @param symbol The cryptocurrency symbol. (required)
     * @param interval The forecast interval, 1h or 1d. (required)
     * @param period The period for computing the error bounds, typically 7d or 30d. (required)
     * @param cookie e.g. csrf&#x3D;b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param xCsrf e.g. b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @return PrivateForecastAccuracyResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public PrivateForecastAccuracyResponse v1PrivateForecastAccuracySymbolIntervalPeriodGet(String symbol, String interval, String period, String cookie, String xCsrf) throws ApiException {
        ApiResponse<PrivateForecastAccuracyResponse> resp = v1PrivateForecastAccuracySymbolIntervalPeriodGetWithHttpInfo(symbol, interval, period, cookie, xCsrf);
        return resp.getData();
    }

    /**
     * Forecast Accuracy
     * 
     * @param symbol The cryptocurrency symbol. (required)
     * @param interval The forecast interval, 1h or 1d. (required)
     * @param period The period for computing the error bounds, typically 7d or 30d. (required)
     * @param cookie e.g. csrf&#x3D;b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param xCsrf e.g. b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @return ApiResponse&lt;PrivateForecastAccuracyResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<PrivateForecastAccuracyResponse> v1PrivateForecastAccuracySymbolIntervalPeriodGetWithHttpInfo(String symbol, String interval, String period, String cookie, String xCsrf) throws ApiException {
        com.squareup.okhttp.Call call = v1PrivateForecastAccuracySymbolIntervalPeriodGetValidateBeforeCall(symbol, interval, period, cookie, xCsrf, null, null);
        Type localVarReturnType = new TypeToken<PrivateForecastAccuracyResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Forecast Accuracy (asynchronously)
     * 
     * @param symbol The cryptocurrency symbol. (required)
     * @param interval The forecast interval, 1h or 1d. (required)
     * @param period The period for computing the error bounds, typically 7d or 30d. (required)
     * @param cookie e.g. csrf&#x3D;b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param xCsrf e.g. b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call v1PrivateForecastAccuracySymbolIntervalPeriodGetAsync(String symbol, String interval, String period, String cookie, String xCsrf, final ApiCallback<PrivateForecastAccuracyResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = v1PrivateForecastAccuracySymbolIntervalPeriodGetValidateBeforeCall(symbol, interval, period, cookie, xCsrf, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<PrivateForecastAccuracyResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for v1PrivateForecastSymbolIntervalGet
     * @param symbol The cryptocurrency symbol. (required)
     * @param interval The forecast interval, 1h or 1d. (required)
     * @param cookie e.g. csrf&#x3D;b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param xCsrf e.g. b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call v1PrivateForecastSymbolIntervalGetCall(String symbol, String interval, String cookie, String xCsrf, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/private/forecast/{symbol}/{interval}"
            .replaceAll("\\{" + "symbol" + "\\}", apiClient.escapeString(symbol.toString()))
            .replaceAll("\\{" + "interval" + "\\}", apiClient.escapeString(interval.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (cookie != null)
        localVarHeaderParams.put("Cookie", apiClient.parameterToString(cookie));
        if (xCsrf != null)
        localVarHeaderParams.put("X-csrf", apiClient.parameterToString(xCsrf));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call v1PrivateForecastSymbolIntervalGetValidateBeforeCall(String symbol, String interval, String cookie, String xCsrf, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'symbol' is set
        if (symbol == null) {
            throw new ApiException("Missing the required parameter 'symbol' when calling v1PrivateForecastSymbolIntervalGet(Async)");
        }
        
        // verify the required parameter 'interval' is set
        if (interval == null) {
            throw new ApiException("Missing the required parameter 'interval' when calling v1PrivateForecastSymbolIntervalGet(Async)");
        }
        

        com.squareup.okhttp.Call call = v1PrivateForecastSymbolIntervalGetCall(symbol, interval, cookie, xCsrf, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Forecast
     * The forecast response contains a sequence of forecasts at the specified intervals, with the following attributes.  + &#x60;time_start&#x60; start time of the period the forecast is applicable for  + &#x60;time_end&#x60; end time of the period the forecast is applicable for  + &#x60;low&#x60; forecasted high during the period  + &#x60;high&#x60; forecasted low during the period  + &#x60;weighted_price&#x60; forecasted weighted price during the period  + &#x60;change_pct&#x60; percent change in price for forecasted weighted_price relative to current price  + &#x60;change_usd&#x60; dollar change in price for forecasted weighted_price relative to current price
     * @param symbol The cryptocurrency symbol. (required)
     * @param interval The forecast interval, 1h or 1d. (required)
     * @param cookie e.g. csrf&#x3D;b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param xCsrf e.g. b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @return PrivateForecastResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public PrivateForecastResponse v1PrivateForecastSymbolIntervalGet(String symbol, String interval, String cookie, String xCsrf) throws ApiException {
        ApiResponse<PrivateForecastResponse> resp = v1PrivateForecastSymbolIntervalGetWithHttpInfo(symbol, interval, cookie, xCsrf);
        return resp.getData();
    }

    /**
     * Forecast
     * The forecast response contains a sequence of forecasts at the specified intervals, with the following attributes.  + &#x60;time_start&#x60; start time of the period the forecast is applicable for  + &#x60;time_end&#x60; end time of the period the forecast is applicable for  + &#x60;low&#x60; forecasted high during the period  + &#x60;high&#x60; forecasted low during the period  + &#x60;weighted_price&#x60; forecasted weighted price during the period  + &#x60;change_pct&#x60; percent change in price for forecasted weighted_price relative to current price  + &#x60;change_usd&#x60; dollar change in price for forecasted weighted_price relative to current price
     * @param symbol The cryptocurrency symbol. (required)
     * @param interval The forecast interval, 1h or 1d. (required)
     * @param cookie e.g. csrf&#x3D;b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param xCsrf e.g. b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @return ApiResponse&lt;PrivateForecastResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<PrivateForecastResponse> v1PrivateForecastSymbolIntervalGetWithHttpInfo(String symbol, String interval, String cookie, String xCsrf) throws ApiException {
        com.squareup.okhttp.Call call = v1PrivateForecastSymbolIntervalGetValidateBeforeCall(symbol, interval, cookie, xCsrf, null, null);
        Type localVarReturnType = new TypeToken<PrivateForecastResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Forecast (asynchronously)
     * The forecast response contains a sequence of forecasts at the specified intervals, with the following attributes.  + &#x60;time_start&#x60; start time of the period the forecast is applicable for  + &#x60;time_end&#x60; end time of the period the forecast is applicable for  + &#x60;low&#x60; forecasted high during the period  + &#x60;high&#x60; forecasted low during the period  + &#x60;weighted_price&#x60; forecasted weighted price during the period  + &#x60;change_pct&#x60; percent change in price for forecasted weighted_price relative to current price  + &#x60;change_usd&#x60; dollar change in price for forecasted weighted_price relative to current price
     * @param symbol The cryptocurrency symbol. (required)
     * @param interval The forecast interval, 1h or 1d. (required)
     * @param cookie e.g. csrf&#x3D;b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param xCsrf e.g. b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call v1PrivateForecastSymbolIntervalGetAsync(String symbol, String interval, String cookie, String xCsrf, final ApiCallback<PrivateForecastResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = v1PrivateForecastSymbolIntervalGetValidateBeforeCall(symbol, interval, cookie, xCsrf, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<PrivateForecastResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for v1PrivateForecastTimeSymbolIntervalPeriodGet
     * @param symbol The cryptocurrency symbol. (required)
     * @param interval The forecast interval, 1h or 1d. (required)
     * @param period The period for computing the error bounds, typically 7d or 30d. (required)
     * @param cookie e.g. csrf&#x3D;b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param xCsrf e.g. b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call v1PrivateForecastTimeSymbolIntervalPeriodGetCall(String symbol, String interval, String period, String cookie, String xCsrf, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/private/forecast-time/{symbol}/{interval}/{period}"
            .replaceAll("\\{" + "symbol" + "\\}", apiClient.escapeString(symbol.toString()))
            .replaceAll("\\{" + "interval" + "\\}", apiClient.escapeString(interval.toString()))
            .replaceAll("\\{" + "period" + "\\}", apiClient.escapeString(period.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (cookie != null)
        localVarHeaderParams.put("Cookie", apiClient.parameterToString(cookie));
        if (xCsrf != null)
        localVarHeaderParams.put("X-csrf", apiClient.parameterToString(xCsrf));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call v1PrivateForecastTimeSymbolIntervalPeriodGetValidateBeforeCall(String symbol, String interval, String period, String cookie, String xCsrf, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'symbol' is set
        if (symbol == null) {
            throw new ApiException("Missing the required parameter 'symbol' when calling v1PrivateForecastTimeSymbolIntervalPeriodGet(Async)");
        }
        
        // verify the required parameter 'interval' is set
        if (interval == null) {
            throw new ApiException("Missing the required parameter 'interval' when calling v1PrivateForecastTimeSymbolIntervalPeriodGet(Async)");
        }
        
        // verify the required parameter 'period' is set
        if (period == null) {
            throw new ApiException("Missing the required parameter 'period' when calling v1PrivateForecastTimeSymbolIntervalPeriodGet(Async)");
        }
        

        com.squareup.okhttp.Call call = v1PrivateForecastTimeSymbolIntervalPeriodGetCall(symbol, interval, period, cookie, xCsrf, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Forecast Time
     * 
     * @param symbol The cryptocurrency symbol. (required)
     * @param interval The forecast interval, 1h or 1d. (required)
     * @param period The period for computing the error bounds, typically 7d or 30d. (required)
     * @param cookie e.g. csrf&#x3D;b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param xCsrf e.g. b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @return PrivateForecastTimeResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public PrivateForecastTimeResponse v1PrivateForecastTimeSymbolIntervalPeriodGet(String symbol, String interval, String period, String cookie, String xCsrf) throws ApiException {
        ApiResponse<PrivateForecastTimeResponse> resp = v1PrivateForecastTimeSymbolIntervalPeriodGetWithHttpInfo(symbol, interval, period, cookie, xCsrf);
        return resp.getData();
    }

    /**
     * Forecast Time
     * 
     * @param symbol The cryptocurrency symbol. (required)
     * @param interval The forecast interval, 1h or 1d. (required)
     * @param period The period for computing the error bounds, typically 7d or 30d. (required)
     * @param cookie e.g. csrf&#x3D;b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param xCsrf e.g. b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @return ApiResponse&lt;PrivateForecastTimeResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<PrivateForecastTimeResponse> v1PrivateForecastTimeSymbolIntervalPeriodGetWithHttpInfo(String symbol, String interval, String period, String cookie, String xCsrf) throws ApiException {
        com.squareup.okhttp.Call call = v1PrivateForecastTimeSymbolIntervalPeriodGetValidateBeforeCall(symbol, interval, period, cookie, xCsrf, null, null);
        Type localVarReturnType = new TypeToken<PrivateForecastTimeResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Forecast Time (asynchronously)
     * 
     * @param symbol The cryptocurrency symbol. (required)
     * @param interval The forecast interval, 1h or 1d. (required)
     * @param period The period for computing the error bounds, typically 7d or 30d. (required)
     * @param cookie e.g. csrf&#x3D;b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param xCsrf e.g. b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call v1PrivateForecastTimeSymbolIntervalPeriodGetAsync(String symbol, String interval, String period, String cookie, String xCsrf, final ApiCallback<PrivateForecastTimeResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = v1PrivateForecastTimeSymbolIntervalPeriodGetValidateBeforeCall(symbol, interval, period, cookie, xCsrf, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<PrivateForecastTimeResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for v1PrivateTrendSymbolGet
     * @param symbol The cryptocurrency symbol. (required)
     * @param cookie e.g. csrf&#x3D;b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param xCsrf e.g. b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call v1PrivateTrendSymbolGetCall(String symbol, String cookie, String xCsrf, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/private/trend/{symbol}"
            .replaceAll("\\{" + "symbol" + "\\}", apiClient.escapeString(symbol.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (cookie != null)
        localVarHeaderParams.put("Cookie", apiClient.parameterToString(cookie));
        if (xCsrf != null)
        localVarHeaderParams.put("X-csrf", apiClient.parameterToString(xCsrf));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call v1PrivateTrendSymbolGetValidateBeforeCall(String symbol, String cookie, String xCsrf, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'symbol' is set
        if (symbol == null) {
            throw new ApiException("Missing the required parameter 'symbol' when calling v1PrivateTrendSymbolGet(Async)");
        }
        

        com.squareup.okhttp.Call call = v1PrivateTrendSymbolGetCall(symbol, cookie, xCsrf, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Trend
     * The trend response contains a collection of forecasts for different intervals with the following attributes.  + &#x60;time_start&#x60; start time of the period the forecast is applicable for  + &#x60;time_end&#x60; end time of the period the forecast is applicable for  + &#x60;interval&#x60; interval in hours that the forecast is applicable for  + &#x60;weighted_price&#x60; forecasted weighted price during the period  + &#x60;change_pct&#x60; percent change in price for forecasted weighted_price relative to current price  + &#x60;change_usd&#x60; dollar change in price for forecasted weighted_price relative to current price
     * @param symbol The cryptocurrency symbol. (required)
     * @param cookie e.g. csrf&#x3D;b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param xCsrf e.g. b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @return PublicTrendResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public PublicTrendResponse v1PrivateTrendSymbolGet(String symbol, String cookie, String xCsrf) throws ApiException {
        ApiResponse<PublicTrendResponse> resp = v1PrivateTrendSymbolGetWithHttpInfo(symbol, cookie, xCsrf);
        return resp.getData();
    }

    /**
     * Trend
     * The trend response contains a collection of forecasts for different intervals with the following attributes.  + &#x60;time_start&#x60; start time of the period the forecast is applicable for  + &#x60;time_end&#x60; end time of the period the forecast is applicable for  + &#x60;interval&#x60; interval in hours that the forecast is applicable for  + &#x60;weighted_price&#x60; forecasted weighted price during the period  + &#x60;change_pct&#x60; percent change in price for forecasted weighted_price relative to current price  + &#x60;change_usd&#x60; dollar change in price for forecasted weighted_price relative to current price
     * @param symbol The cryptocurrency symbol. (required)
     * @param cookie e.g. csrf&#x3D;b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param xCsrf e.g. b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @return ApiResponse&lt;PublicTrendResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<PublicTrendResponse> v1PrivateTrendSymbolGetWithHttpInfo(String symbol, String cookie, String xCsrf) throws ApiException {
        com.squareup.okhttp.Call call = v1PrivateTrendSymbolGetValidateBeforeCall(symbol, cookie, xCsrf, null, null);
        Type localVarReturnType = new TypeToken<PublicTrendResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Trend (asynchronously)
     * The trend response contains a collection of forecasts for different intervals with the following attributes.  + &#x60;time_start&#x60; start time of the period the forecast is applicable for  + &#x60;time_end&#x60; end time of the period the forecast is applicable for  + &#x60;interval&#x60; interval in hours that the forecast is applicable for  + &#x60;weighted_price&#x60; forecasted weighted price during the period  + &#x60;change_pct&#x60; percent change in price for forecasted weighted_price relative to current price  + &#x60;change_usd&#x60; dollar change in price for forecasted weighted_price relative to current price
     * @param symbol The cryptocurrency symbol. (required)
     * @param cookie e.g. csrf&#x3D;b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param xCsrf e.g. b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call v1PrivateTrendSymbolGetAsync(String symbol, String cookie, String xCsrf, final ApiCallback<PublicTrendResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = v1PrivateTrendSymbolGetValidateBeforeCall(symbol, cookie, xCsrf, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<PublicTrendResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for v1PrivateTrendTabularGet
     * @param cookie e.g. csrf&#x3D;b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param xCsrf e.g. b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call v1PrivateTrendTabularGetCall(String cookie, String xCsrf, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/private/trend-tabular";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (cookie != null)
        localVarHeaderParams.put("Cookie", apiClient.parameterToString(cookie));
        if (xCsrf != null)
        localVarHeaderParams.put("X-csrf", apiClient.parameterToString(xCsrf));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call v1PrivateTrendTabularGetValidateBeforeCall(String cookie, String xCsrf, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        

        com.squareup.okhttp.Call call = v1PrivateTrendTabularGetCall(cookie, xCsrf, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Trend Tabular
     * The trend tabular response contains a collection of forecasts for all supported cryptocurrencies at different intervals with the following attributes.  + &#x60;time_start&#x60; start time of the period the forecast is applicable for  + &#x60;time_end&#x60; end time of the period the forecast is applicable for  + &#x60;interval&#x60; interval in hours that the forecast is applicable for  + &#x60;weighted_price&#x60; forecasted weighted price during the period  + &#x60;change_pct&#x60; percent change in price for forecasted weighted_price relative to current price  + &#x60;change_usd&#x60; dollar change in price for forecasted weighted_price relative to current price
     * @param cookie e.g. csrf&#x3D;b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param xCsrf e.g. b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @return PrivateTrendTabularResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public PrivateTrendTabularResponse v1PrivateTrendTabularGet(String cookie, String xCsrf) throws ApiException {
        ApiResponse<PrivateTrendTabularResponse> resp = v1PrivateTrendTabularGetWithHttpInfo(cookie, xCsrf);
        return resp.getData();
    }

    /**
     * Trend Tabular
     * The trend tabular response contains a collection of forecasts for all supported cryptocurrencies at different intervals with the following attributes.  + &#x60;time_start&#x60; start time of the period the forecast is applicable for  + &#x60;time_end&#x60; end time of the period the forecast is applicable for  + &#x60;interval&#x60; interval in hours that the forecast is applicable for  + &#x60;weighted_price&#x60; forecasted weighted price during the period  + &#x60;change_pct&#x60; percent change in price for forecasted weighted_price relative to current price  + &#x60;change_usd&#x60; dollar change in price for forecasted weighted_price relative to current price
     * @param cookie e.g. csrf&#x3D;b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param xCsrf e.g. b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @return ApiResponse&lt;PrivateTrendTabularResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<PrivateTrendTabularResponse> v1PrivateTrendTabularGetWithHttpInfo(String cookie, String xCsrf) throws ApiException {
        com.squareup.okhttp.Call call = v1PrivateTrendTabularGetValidateBeforeCall(cookie, xCsrf, null, null);
        Type localVarReturnType = new TypeToken<PrivateTrendTabularResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Trend Tabular (asynchronously)
     * The trend tabular response contains a collection of forecasts for all supported cryptocurrencies at different intervals with the following attributes.  + &#x60;time_start&#x60; start time of the period the forecast is applicable for  + &#x60;time_end&#x60; end time of the period the forecast is applicable for  + &#x60;interval&#x60; interval in hours that the forecast is applicable for  + &#x60;weighted_price&#x60; forecasted weighted price during the period  + &#x60;change_pct&#x60; percent change in price for forecasted weighted_price relative to current price  + &#x60;change_usd&#x60; dollar change in price for forecasted weighted_price relative to current price
     * @param cookie e.g. csrf&#x3D;b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param xCsrf e.g. b1820141-1bad-4a9c-93c0-52022817ce89 (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call v1PrivateTrendTabularGetAsync(String cookie, String xCsrf, final ApiCallback<PrivateTrendTabularResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = v1PrivateTrendTabularGetValidateBeforeCall(cookie, xCsrf, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<PrivateTrendTabularResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
